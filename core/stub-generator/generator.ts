import * as fs from "fs-extra";
import * as path from "path";
import { TProcessingError, TScenarioData, TStepData } from "../types";

class TestCodeGenerator implements TContract {
  async generateTestFiles(
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void> {
    try {
      // ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±
      await fs.ensureDir(outputDir);

      // ì‹œë‚˜ë¦¬ì˜¤ë¥¼ prefixë³„ë¡œ ê·¸ë£¹í™” (TC-1.1, TC-1.2 -> TC-1)
      const groupedScenarios = this.#groupScenariosByPrefix(scenarios);

      // ê° prefixë³„ë¡œ í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„±
      const fileGenerationPromises = Array.from(groupedScenarios.entries()).map(
        ([prefix, scenarioGroup]) =>
          this.#generateGroupTestFile(prefix, scenarioGroup, outputDir)
      );

      await Promise.all(fileGenerationPromises);
    } catch (error) {
      throw this.#createProcessingError(
        "FILE_WRITE",
        `í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„± ì‹¤íŒ¨: ${
          error instanceof Error ? error.message : String(error)
        }`,
        outputDir,
        error as Error
      );
    }
  }

  generateGroupTestCode(scenarios: TScenarioData[]): string {
    const imports = this.#generateImports();
    const testCodes = scenarios
      .map((scenario) => this.#generateTestForScenario(scenario))
      .join("\n\n");

    const scenarioIds = scenarios.map((s) => s.scenarioId).join(", ");

    return `// ğŸ“ Auto-generated by E2E-Autogen
// ğŸ”§ Generated from: ${scenarioIds}

${imports}

${testCodes}`;
  }

  #groupScenariosByPrefix(
    scenarios: TScenarioData[]
  ): Map<string, TScenarioData[]> {
    const grouped = new Map<string, TScenarioData[]>();

    scenarios.forEach((scenario) => {
      const prefix = scenario.scenarioId.split(".")[0]; // TC-1.1 -> TC-1

      if (!grouped.has(prefix)) {
        grouped.set(prefix, []);
      }
      grouped.get(prefix)!.push(scenario);
    });

    return grouped;
  }

  async #generateGroupTestFile(
    prefix: string,
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void> {
    try {
      const fileName = `${prefix}.spec.ts`;
      const filePath = path.join(outputDir, fileName);

      // í…ŒìŠ¤íŠ¸ ì½”ë“œ ìƒì„±
      const testCode = this.generateGroupTestCode(scenarios);

      // íŒŒì¼ ì“°ê¸°
      await fs.writeFile(filePath, testCode, "utf-8");
      console.log(`âœ… ìƒì„±ë¨: ${filePath} (${scenarios.length}ê°œ ì‹œë‚˜ë¦¬ì˜¤)`);
    } catch (error) {
      throw this.#createProcessingError(
        "FILE_WRITE",
        `í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„± ì‹¤íŒ¨ (${prefix}): ${
          error instanceof Error ? error.message : String(error)
        }`,
        outputDir,
        error as Error
      );
    }
  }

  #generateImports(): string {
    return `import { test } from "@playwright/test";`;
  }

  #generateTestForScenario(scenario: TScenarioData): string {
    const scenarioTitle = this.#sanitizeTestName(
      `[${scenario.scenarioId}] ${scenario.scenario}`
    );
    const steps = this.#generateSteps(scenario.steps);

    return `test("${scenarioTitle}", async ({ page }) => {
${steps}
});`;
  }

  #generateSteps(steps: TStepData[]): string {
    return steps.map((step) => this.#generateStep(step)).join("\n\n");
  }

  #generateStep(step: TStepData): string {
    const stepTitle = step.when.trim()
      ? this.#sanitizeTestName(`[${step.testId}] ${step.when} -> ${step.then}`)
      : this.#sanitizeTestName(`[${step.testId}] ${step.then}`);

    const whenComment = this.#sanitizeComment(step.when);
    const thenComment = this.#sanitizeComment(step.then);

    const whenSection = step.when.trim()
      ? `    // ğŸ¬ When: ${whenComment}\n    \n`
      : "";

    return `  await test.step("${stepTitle}", async () => {
    // ğŸ“ UI Path: ${step.uiPath}
    
${whenSection}    // âœ… Then: ${thenComment}
    
  });`;
  }

  #sanitizeTestName(name: string): string {
    return name
      .replace(/"/g, '\\"') // ìŒë”°ì˜´í‘œ ì´ìŠ¤ì¼€ì´í”„
      .replace(/\n/g, " ") // ê°œí–‰ ë¬¸ì ì œê±°
      .replace(/\s+/g, " ") // ì—°ì†ëœ ê³µë°± ì •ë¦¬
      .trim();
  }

  #sanitizeComment(comment: string): string {
    return comment
      .replace(/\n/g, " ") // ê°œí–‰ ë¬¸ì ì œê±°
      .replace(/\s+/g, " ") // ì—°ì†ëœ ê³µë°± ì •ë¦¬
      .trim();
  }

  #createProcessingError(
    type: TProcessingError["type"],
    message: string,
    filePath?: string,
    originalError?: Error
  ): TProcessingError {
    return {
      type,
      message,
      filePath,
      originalError,
    };
  }
}

export { TestCodeGenerator };

type TContract = {
  generateTestFiles(
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void>;
};
