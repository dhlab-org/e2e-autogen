import * as fs from "fs-extra";
import * as path from "path";
import { TProcessingError, TScenarioData, TStepData } from "../types";

class TestCodeGenerator implements TContract {
  async generateTestFiles(
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void> {
    try {
      // 출력 디렉토리 생성
      await fs.ensureDir(outputDir);

      // 시나리오를 prefix별로 그룹화 (TC-1.1, TC-1.2 -> TC-1)
      const groupedScenarios = this.#groupScenariosByPrefix(scenarios);

      // 각 prefix별로 테스트 파일 생성
      const fileGenerationPromises = Array.from(groupedScenarios.entries()).map(
        ([prefix, scenarioGroup]) =>
          this.#generateGroupTestFile(prefix, scenarioGroup, outputDir)
      );

      await Promise.all(fileGenerationPromises);
    } catch (error) {
      throw this.#createProcessingError(
        "FILE_WRITE",
        `테스트 파일 생성 실패: ${
          error instanceof Error ? error.message : String(error)
        }`,
        outputDir,
        error as Error
      );
    }
  }

  generateGroupTestCode(scenarios: TScenarioData[]): string {
    const imports = this.#generateImports();
    const testCodes = scenarios
      .map((scenario) => this.#generateTestForScenario(scenario))
      .join("\n\n");

    const scenarioIds = scenarios.map((s) => s.scenarioId).join(", ");

    return `// 📝 Auto-generated by E2E-Autogen
// 🔧 Generated from: ${scenarioIds}

${imports}

${testCodes}`;
  }

  #groupScenariosByPrefix(
    scenarios: TScenarioData[]
  ): Map<string, TScenarioData[]> {
    const grouped = new Map<string, TScenarioData[]>();

    scenarios.forEach((scenario) => {
      const prefix = scenario.scenarioId.split(".")[0]; // TC-1.1 -> TC-1

      if (!grouped.has(prefix)) {
        grouped.set(prefix, []);
      }
      grouped.get(prefix)!.push(scenario);
    });

    return grouped;
  }

  async #generateGroupTestFile(
    prefix: string,
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void> {
    try {
      const fileName = `${prefix}.spec.ts`;
      const filePath = path.join(outputDir, fileName);

      // 테스트 코드 생성
      const testCode = this.generateGroupTestCode(scenarios);

      // 파일 쓰기
      await fs.writeFile(filePath, testCode, "utf-8");
      console.log(`✅ 생성됨: ${filePath} (${scenarios.length}개 시나리오)`);
    } catch (error) {
      throw this.#createProcessingError(
        "FILE_WRITE",
        `테스트 파일 생성 실패 (${prefix}): ${
          error instanceof Error ? error.message : String(error)
        }`,
        outputDir,
        error as Error
      );
    }
  }

  #generateImports(): string {
    return `import { test } from "@playwright/test";`;
  }

  #generateTestForScenario(scenario: TScenarioData): string {
    const scenarioTitle = this.#sanitizeTestName(
      `[${scenario.scenarioId}] ${scenario.scenario}`
    );
    const steps = this.#generateSteps(scenario.steps);

    return `test("${scenarioTitle}", async ({ page }) => {
${steps}
});`;
  }

  #generateSteps(steps: TStepData[]): string {
    return steps.map((step) => this.#generateStep(step)).join("\n\n");
  }

  #generateStep(step: TStepData): string {
    const stepTitle = step.when.trim()
      ? this.#sanitizeTestName(`[${step.testId}] ${step.when} -> ${step.then}`)
      : this.#sanitizeTestName(`[${step.testId}] ${step.then}`);

    const whenComment = this.#sanitizeComment(step.when);
    const thenComment = this.#sanitizeComment(step.then);

    const whenSection = step.when.trim()
      ? `    // 🎬 When: ${whenComment}\n    \n`
      : "";

    return `  await test.step("${stepTitle}", async () => {
    // 📍 UI Path: ${step.uiPath}
    
${whenSection}    // ✅ Then: ${thenComment}
    
  });`;
  }

  #sanitizeTestName(name: string): string {
    return name
      .replace(/"/g, '\\"') // 쌍따옴표 이스케이프
      .replace(/\n/g, " ") // 개행 문자 제거
      .replace(/\s+/g, " ") // 연속된 공백 정리
      .trim();
  }

  #sanitizeComment(comment: string): string {
    return comment
      .replace(/\n/g, " ") // 개행 문자 제거
      .replace(/\s+/g, " ") // 연속된 공백 정리
      .trim();
  }

  #createProcessingError(
    type: TProcessingError["type"],
    message: string,
    filePath?: string,
    originalError?: Error
  ): TProcessingError {
    return {
      type,
      message,
      filePath,
      originalError,
    };
  }
}

export { TestCodeGenerator };

type TContract = {
  generateTestFiles(
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void>;
};
