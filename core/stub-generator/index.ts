import * as fs from "fs-extra";
import * as path from "path";
import {
  TProcessingError,
  TScenarioData,
  TStepData,
  DEFAULT_DIRECTORIES,
} from "../types";

type TContract = {
  generate(scenarios: TScenarioData[], outputDir?: string): Promise<void>;
};

class PlaywrightStubGenerator implements TContract {
  async generate(
    scenarios: TScenarioData[],
    outputDir: string = DEFAULT_DIRECTORIES.generatedStub
  ): Promise<void> {
    console.log(`ğŸš€ ì‹œë‚˜ë¦¬ì˜¤ ë°ì´í„° â†’ ${outputDir}`);

    if (scenarios.length === 0) {
      console.log("âš ï¸  ì²˜ë¦¬í•  ì‹œë‚˜ë¦¬ì˜¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    await this.#generateTestFiles(scenarios, outputDir);
    console.log(`âœ… ${scenarios.length}ê°œ ì‹œë‚˜ë¦¬ì˜¤ ì²˜ë¦¬ ì™„ë£Œ`);
  }

  async #generateTestFiles(
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void> {
    try {
      // ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±
      await fs.ensureDir(outputDir);

      // ì‹œë‚˜ë¦¬ì˜¤ë¥¼ prefixë³„ë¡œ ê·¸ë£¹í™” (TC-1.1, TC-1.2 -> TC-1)
      const groupedScenarios = this.#groupScenariosByPrefix(scenarios);

      // ê° prefixë³„ë¡œ í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„±
      await Promise.all(
        Array.from(groupedScenarios.entries()).map(([prefix, scenarioGroup]) =>
          this.#generateGroupTestFile(prefix, scenarioGroup, outputDir)
        )
      );
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜";
      throw this.#createProcessingError(
        "FILE_WRITE",
        `í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„± ì‹¤íŒ¨: ${errorMessage}`,
        outputDir,
        error as Error
      );
    }
  }

  #groupScenariosByPrefix(
    scenarios: TScenarioData[]
  ): Map<string, TScenarioData[]> {
    return scenarios.reduce((grouped, scenario) => {
      const prefix = scenario.scenarioId.split(".")[0]; // TC-1.1 -> TC-1
      const existingGroup = grouped.get(prefix) ?? [];
      return grouped.set(prefix, [...existingGroup, scenario]);
    }, new Map<string, TScenarioData[]>());
  }

  async #generateGroupTestFile(
    prefix: string,
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void> {
    try {
      const fileName = `${prefix}.stub.ts`;
      const filePath = path.join(outputDir, fileName);

      // í…ŒìŠ¤íŠ¸ ì½”ë“œ ìƒì„±
      const testCode = this.#groupTestCode(scenarios);

      // íŒŒì¼ ì“°ê¸°
      await fs.writeFile(filePath, testCode, "utf-8");
      console.log(`âœ… ìƒì„±ë¨: ${filePath} (${scenarios.length}ê°œ ì‹œë‚˜ë¦¬ì˜¤)`);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜";
      throw this.#createProcessingError(
        "FILE_WRITE",
        `í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„± ì‹¤íŒ¨ (${prefix}): ${errorMessage}`,
        outputDir,
        error as Error
      );
    }
  }

  #groupTestCode(scenarios: TScenarioData[]): string {
    const scenarioIds = scenarios.map((s) => s.scenarioId).join(", ");
    const testCodes = scenarios
      .map((scenario) => this.#generateTestForScenario(scenario))
      .join("\n\n");

    return [
      "// ğŸ“ Auto-generated by E2E-Autogen",
      `// ğŸ”§ Generated from: ${scenarioIds}`,
      "",
      `import { test } from "@playwright/test";`,
      "",
      testCodes,
    ].join("\n");
  }

  #generateTestForScenario(scenario: TScenarioData): string {
    const scenarioTitle = this.#sanitizeText(
      `[${scenario.scenarioId}] ${scenario.scenario}`,
      true
    );
    const steps = scenario.steps
      .map((step) => this.#generateStep(step))
      .join("\n\n");

    return `test.skip("${scenarioTitle}", async ({ page }) => {
${steps}
});`;
  }

  #generateStep(step: TStepData): string {
    const hasUiPath = step.uiPath.trim().length > 0;
    const hasWhen = step.when.trim().length > 0;
    const stepTitle = this.#sanitizeText(
      hasWhen
        ? `[${step.testId}] ${step.when} -> ${step.then}`
        : `[${step.testId}] ${step.then}`,
      true
    );

    const uiPathSection = hasUiPath ? `// ğŸ“ UI Path: ${step.uiPath}\n` : "";
    const whenSection = hasWhen
      ? `// ğŸ¬ When: ${this.#sanitizeText(step.when)}\n`
      : "";
    const thenSection = `// âœ… Then: ${this.#sanitizeText(step.then)}\n`;

    return `  await test.step.skip("${stepTitle}", async () => {
      ${uiPathSection}
      ${whenSection}    
      ${thenSection}
    });`;
  }

  #sanitizeText(text: string, escapeQuotes: boolean = false): string {
    let result = text
      .replace(/\n/g, " ") // ê°œí–‰ ë¬¸ì ì œê±°
      .replace(/\s+/g, " ") // ì—°ì†ëœ ê³µë°± ì •ë¦¬
      .trim();

    if (escapeQuotes) {
      result = result.replace(/"/g, '\\"'); // ìŒë”°ì˜´í‘œ ì´ìŠ¤ì¼€ì´í”„
    }

    return result;
  }

  #createProcessingError(
    type: TProcessingError["type"],
    message: string,
    filePath?: string,
    originalError?: Error
  ): TProcessingError {
    return {
      type,
      message,
      filePath,
      originalError,
    };
  }
}

export { PlaywrightStubGenerator };
