import * as fs from "fs-extra";
import * as path from "path";
import { TPrefix, TScenarioData, TStepData } from "./types";

type PlaywrightTemplateContract = {
  write(targetDir: string): Promise<void>;
};

class PlaywrightTemplate implements PlaywrightTemplateContract {
  readonly #scenariosPerPrefix: Map<TPrefix, TScenarioData[]>;

  constructor(scenariosPerPrefix: Map<TPrefix, TScenarioData[]>) {
    this.#scenariosPerPrefix = scenariosPerPrefix;
  }

  async write(targetDir: string): Promise<void> {
    try {
      await fs.ensureDir(targetDir);

      await Promise.all(
        Array.from(this.#scenariosPerPrefix.entries()).map(
          ([prefix, scenarios]) =>
            this.#generateStubFile(prefix, scenarios, targetDir)
        )
      );
    } catch (error) {
      throw new Error(`âŒ Playwright ìŠ¤í… ì½”ë“œ file write ì‹¤íŒ¨: ${error}`);
    }
  }

  async #generateStubFile(
    prefix: TPrefix,
    scenarios: TScenarioData[],
    targetDir: string
  ): Promise<void> {
    const fileName = `${prefix}.stub.ts`;
    const filePath = path.join(targetDir, fileName);

    const template = this.#template(scenarios);

    await fs.writeFile(filePath, template, "utf-8");
    console.log(`âœ… ìƒì„±ë¨: ${filePath} (${scenarios.length}ê°œ ì‹œë‚˜ë¦¬ì˜¤)`);
  }

  #template(scenarios: TScenarioData[]): string {
    const scenarioIds = scenarios.map((s) => s.scenarioId).join(", ");
    const stubCodes = scenarios
      .map((scenario) => this.#stubCode(scenario))
      .join("\n\n");

    return [
      "// ğŸ“ Auto-generated by E2E-Autogen",
      `// ğŸ”§ Generated from: ${scenarioIds}`,
      "",
      `import { test } from "@playwright/test";`,
      "",
      stubCodes,
    ].join("\n");
  }

  #stubCode(scenario: TScenarioData): string {
    const title = this.#sanitizeText(
      `[${scenario.scenarioId}] ${scenario.scenarioDescription}`,
      true
    );

    const steps = scenario.steps
      .map((step) => this.#stepCode(step))
      .join("\n\n");

    return [`test.skip("${title}", async ({ page }) => {`, steps, "});"].join(
      "\n"
    );
  }

  #stepCode(step: TStepData): string {
    const hasUiPath = step.uiPath.trim().length > 0;
    const hasWhen = step.when.trim().length > 0;
    const stepTitle = this.#sanitizeText(
      hasWhen
        ? `[${step.testId}] ${step.when} -> ${step.then}`
        : `[${step.testId}] ${step.then}`,
      true
    );

    const uiPathSection = hasUiPath ? `// ğŸ“ UI Path: ${step.uiPath}\n` : "";
    const whenSection = hasWhen
      ? `// ğŸ¬ When: ${this.#sanitizeText(step.when)}\n`
      : "";
    const thenSection = `// âœ… Then: ${this.#sanitizeText(step.then)}\n`;

    return `  await test.step.skip("${stepTitle}", async () => {
      ${uiPathSection}
      ${whenSection}    
      ${thenSection}
    });`;
  }

  #sanitizeText(text: string, escapeQuotes: boolean = false): string {
    let result = text
      .replace(/\n/g, " ") // ê°œí–‰ ë¬¸ì ì œê±°
      .replace(/\s+/g, " ") // ì—°ì†ëœ ê³µë°± ì •ë¦¬
      .trim();

    if (escapeQuotes) {
      result = result.replace(/"/g, '\\"'); // ìŒë”°ì˜´í‘œ ì´ìŠ¤ì¼€ì´í”„
    }

    return result;
  }
}

export { PlaywrightTemplate };
