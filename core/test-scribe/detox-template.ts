import * as path from "node:path";
import * as fs from "fs-extra";
import type { TPrefix, TScenarioData, TStepData } from "./types";

type DetoxTemplateContract = {
  write(targetDir: string): Promise<void>;
};

class DetoxTemplate implements DetoxTemplateContract {
  readonly #scenariosPerPrefix: Map<TPrefix, TScenarioData[]>;

  constructor(scenariosPerPrefix: Map<TPrefix, TScenarioData[]>) {
    this.#scenariosPerPrefix = scenariosPerPrefix;
  }

  async write(targetDir: string): Promise<void> {
    try {
      await fs.ensureDir(targetDir);

      await Promise.all(
        Array.from(this.#scenariosPerPrefix.entries()).map(
          ([prefix, scenarios]) =>
            this.#generateStubFile(prefix, scenarios, targetDir)
        )
      );
    } catch (error) {
      throw new Error(`❌ Detox 스텁 코드 file write 실패: ${error}`);
    }
  }

  async #generateStubFile(
    prefix: TPrefix,
    scenarios: TScenarioData[],
    targetDir: string
  ): Promise<void> {
    const fileName = `${prefix}.stub.ts`;
    const filePath = path.join(targetDir, fileName);

    const template = this.#template(scenarios);

    await fs.writeFile(filePath, template, "utf-8");
    console.log(`✅ 생성됨: ${filePath} (${scenarios.length}개 시나리오)`);
  }

  #template(scenarios: TScenarioData[]): string {
    const scenarioIds = scenarios.map((s) => s.scenarioId).join(", ");
    const stubCodes = scenarios
      .map((scenario) => this.#stubCode(scenario))
      .join("\n\n");

    return [
      "// 📝 Auto-generated by E2E-Autogen",
      `// 🔧 Generated from: ${scenarioIds}`,
      "",
      "// Detox step utility for sequential test execution",
      "const step = {",
      "  skip: (title: string, fn: () => Promise<void>) => {",
      "    // Skip step implementation - can be enabled later",
      "    console.log(`⏭️ Skipping: ${title}`);",
      "  },",
      "  test: async (title: string, fn: () => Promise<void>) => {",
      "    console.log(`🎬 Step: ${title}`);",
      "    await fn();",
      "  }",
      "};",
      "",
      `describe("${scenarios[0]?.scenarioId || "E2E Test"}", () => {`,
      "  beforeEach(async () => {",
      "    await device.launchApp({ newInstance: true });",
      "  });",
      "",
      stubCodes,
      "});",
    ].join("\n");
  }

  #stubCode(scenario: TScenarioData): string {
    const title = this.#sanitizeText(
      `[${scenario.scenarioId}] ${scenario.scenarioDescription}`,
      true
    );

    const steps = scenario.steps
      .map((step) => this.#stepCode(step))
      .join("\n\n");

    return [`  it.skip("${title}", async () => {`, steps, "  });"].join("\n");
  }

  #stepCode(step: TStepData): string {
    const hasUiPath = step.uiPath.trim().length > 0;
    const hasWhen = step.action.trim().length > 0;
    const stepTitle = this.#sanitizeText(
      hasWhen
        ? `[${step.testId}] ${step.action} -> ${step.expected}`
        : `[${step.testId}] ${step.expected}`,
      true
    );

    const uiPathSection = hasUiPath ? `// 📍 UI Path: ${step.uiPath}\n` : "";
    const whenSection = hasWhen
      ? `// 🎬 When: ${this.#sanitizeText(step.action)}\n`
      : "";
    const thenSection = `// ✅ Then: ${this.#sanitizeText(step.expected)}\n`;

    return `    await step.test("${stepTitle}", async () => {
      ${uiPathSection}
      ${whenSection}
      ${thenSection}
    });`;
  }

  #sanitizeText(text: string, escapeQuotes: boolean = false): string {
    let result = text
      .replace(/\n/g, " ") // 개행 문자 제거
      .replace(/\s+/g, " ") // 연속된 공백 정리
      .trim();

    if (escapeQuotes) {
      result = result.replace(/"/g, '\\"'); // 쌍따옴표 이스케이프
    }

    return result;
  }
}

export { DetoxTemplate };
