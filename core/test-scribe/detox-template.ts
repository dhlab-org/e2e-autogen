import * as path from "node:path";
import * as fs from "fs-extra";
import type { TPrefix, TScenarioData, TStepData } from "./types";

type DetoxTemplateContract = {
  write(targetDir: string): Promise<void>;
};

class DetoxTemplate implements DetoxTemplateContract {
  readonly #scenariosPerPrefix: Map<TPrefix, TScenarioData[]>;

  constructor(scenariosPerPrefix: Map<TPrefix, TScenarioData[]>) {
    this.#scenariosPerPrefix = scenariosPerPrefix;
  }

  async write(targetDir: string): Promise<void> {
    try {
      await fs.ensureDir(targetDir);

      await Promise.all(
        Array.from(this.#scenariosPerPrefix.entries()).map(
          ([prefix, scenarios]) =>
            this.#generateStubFile(prefix, scenarios, targetDir)
        )
      );
    } catch (error) {
      throw new Error(`âŒ Detox ìŠ¤í… ì½”ë“œ file write ì‹¤íŒ¨: ${error}`);
    }
  }

  async #generateStubFile(
    prefix: TPrefix,
    scenarios: TScenarioData[],
    targetDir: string
  ): Promise<void> {
    const fileName = `${prefix}.stub.ts`;
    const filePath = path.join(targetDir, fileName);

    const template = this.#template(scenarios);

    await fs.writeFile(filePath, template, "utf-8");
    console.log(`âœ… ìƒì„±ë¨: ${filePath} (${scenarios.length}ê°œ ì‹œë‚˜ë¦¬ì˜¤)`);
  }

  #template(scenarios: TScenarioData[]): string {
    const scenarioIds = scenarios.map((s) => s.scenarioId).join(", ");
    const stubCodes = scenarios
      .map((scenario) => this.#stubCode(scenario))
      .join("\n\n");

    return [
      "// ğŸ“ Auto-generated by E2E-Autogen",
      `// ğŸ”§ Generated from: ${scenarioIds}`,
      "",
      "// Detox step utility for sequential test execution",
      "const step = {",
      "  skip: (title: string, fn: () => Promise<void>) => {",
      "    // Skip step implementation - can be enabled later",
      "    console.log(`â­ï¸ Skipping: ${title}`);",
      "  },",
      "  test: async (title: string, fn: () => Promise<void>) => {",
      "    console.log(`ğŸ¬ Step: ${title}`);",
      "    await fn();",
      "  }",
      "};",
      "",
      `describe("${scenarios[0]?.scenarioId || "E2E Test"}", () => {`,
      "  beforeEach(async () => {",
      "    await device.launchApp({ newInstance: true });",
      "  });",
      "",
      stubCodes,
      "});",
    ].join("\n");
  }

  #stubCode(scenario: TScenarioData): string {
    const title = this.#sanitizeText(
      `[${scenario.scenarioId}] ${scenario.scenarioDescription}`,
      true
    );

    const steps = scenario.steps
      .map((step) => this.#stepCode(step))
      .join("\n\n");

    return [`  it.skip("${title}", async () => {`, steps, "  });"].join("\n");
  }

  #stepCode(step: TStepData): string {
    const hasUiPath = step.uiPath.trim().length > 0;
    const hasWhen = step.action.trim().length > 0;
    const stepTitle = this.#sanitizeText(
      hasWhen
        ? `[${step.testId}] ${step.action} -> ${step.expected}`
        : `[${step.testId}] ${step.expected}`,
      true
    );

    const uiPathSection = hasUiPath ? `// ğŸ“ UI Path: ${step.uiPath}\n` : "";
    const whenSection = hasWhen
      ? `// ğŸ¬ When: ${this.#sanitizeText(step.action)}\n`
      : "";
    const thenSection = `// âœ… Then: ${this.#sanitizeText(step.expected)}\n`;

    return `    await step.test("${stepTitle}", async () => {
      ${uiPathSection}
      ${whenSection}
      ${thenSection}
    });`;
  }

  #sanitizeText(text: string, escapeQuotes: boolean = false): string {
    let result = text
      .replace(/\n/g, " ") // ê°œí–‰ ë¬¸ì ì œê±°
      .replace(/\s+/g, " ") // ì—°ì†ëœ ê³µë°± ì •ë¦¬
      .trim();

    if (escapeQuotes) {
      result = result.replace(/"/g, '\\"'); // ìŒë”°ì˜´í‘œ ì´ìŠ¤ì¼€ì´í”„
    }

    return result;
  }
}

export { DetoxTemplate };
