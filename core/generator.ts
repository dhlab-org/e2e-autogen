import * as fs from "fs-extra";
import * as path from "path";
import {
  TScenarioData,
  TTestCase,
  TTestCodeGeneratorContract,
  TTestFileInfo,
  TProcessingError,
} from "./types";

class TestCodeGenerator implements TTestCodeGeneratorContract {
  /**
   * ì‹œë‚˜ë¦¬ì˜¤ ë°ì´í„°ë¡œë¶€í„° Playwright í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
   * @param scenarios ì‹œë‚˜ë¦¬ì˜¤ ë°ì´í„° ë°°ì—´
   * @param outputDir ì¶œë ¥ ë””ë ‰í† ë¦¬ ê²½ë¡œ
   * @throws {TProcessingError} íŒŒì¼ ìƒì„± ì‹¤íŒ¨ ì‹œ
   */
  async generateTestFiles(
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void> {
    try {
      // ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±
      await fs.ensureDir(outputDir);

      // screenIdë³„ë¡œ ê·¸ë£¹í™”
      const groupedByScreen = this.groupByScreenId(scenarios);

      // ê° screenIdë³„ë¡œ í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„±
      const fileGenerationPromises = Array.from(groupedByScreen.entries()).map(
        ([screenId, screenScenarios]) =>
          this.generateTestFile(screenId, screenScenarios, outputDir)
      );

      await Promise.all(fileGenerationPromises);
    } catch (error) {
      throw this.createProcessingError(
        "FILE_WRITE",
        `í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„± ì‹¤íŒ¨: ${
          error instanceof Error ? error.message : String(error)
        }`,
        outputDir,
        error as Error
      );
    }
  }

  /**
   * ë‹¨ì¼ í™”ë©´ì— ëŒ€í•œ í…ŒìŠ¤íŠ¸ íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤.
   * @param screenId í™”ë©´ ID
   * @param scenarios í•´ë‹¹ í™”ë©´ì˜ ì‹œë‚˜ë¦¬ì˜¤ë“¤
   * @param outputDir ì¶œë ¥ ë””ë ‰í† ë¦¬
   * @returns ìƒì„±ëœ íŒŒì¼ ì •ë³´
   */
  private async generateTestFile(
    screenId: string,
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<TTestFileInfo> {
    try {
      // sheetIdë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸°ëŠ¥ ì˜ì—­ í´ë” ìƒì„±
      const sheetId = scenarios[0].sheetId;
      const featureDir = path.join(outputDir, sheetId);
      await fs.ensureDir(featureDir);

      const fileName = `${screenId}.spec.ts`;
      const filePath = path.join(featureDir, fileName);

      // í…ŒìŠ¤íŠ¸ ì½”ë“œ ìƒì„±
      const testCode = this.generateTestCode(scenarios);

      // íŒŒì¼ ì“°ê¸°
      await fs.writeFile(filePath, testCode, "utf-8");
      console.log(`âœ… ìƒì„±ë¨: ${filePath}`);

      return {
        fileName,
        filePath,
        screenId,
        sheetId,
      };
    } catch (error) {
      throw this.createProcessingError(
        "FILE_WRITE",
        `í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„± ì‹¤íŒ¨ (${screenId}): ${
          error instanceof Error ? error.message : String(error)
        }`,
        outputDir,
        error as Error
      );
    }
  }

  /**
   * Playwright í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
   * @param screenId í™”ë©´ ID
   * @param scenarios ì‹œë‚˜ë¦¬ì˜¤ ë°ì´í„° ë°°ì—´
   * @returns ìƒì„±ëœ í…ŒìŠ¤íŠ¸ ì½”ë“œ
   */
  generateTestCode(scenarios: TScenarioData[]): string {
    const imports = this.generateImports();
    const testGroups = this.generateTestGroups(scenarios);

    return `// ğŸ“ Auto-generated by E2E-Autogen

${imports}

${testGroups}`;
  }

  /**
   * import ë¬¸ì„ ìƒì„±í•©ë‹ˆë‹¤.
   * @returns import ë¬¸
   */
  private generateImports(): string {
    return `import { test } from "@playwright/test";`;
  }

  /**
   * í…ŒìŠ¤íŠ¸ ê·¸ë£¹ë“¤ì„ ìƒì„±í•©ë‹ˆë‹¤.
   * @param scenarios ì‹œë‚˜ë¦¬ì˜¤ ë°ì´í„° ë°°ì—´
   * @returns í…ŒìŠ¤íŠ¸ ê·¸ë£¹ ì½”ë“œ
   */
  private generateTestGroups(scenarios: TScenarioData[]): string {
    return scenarios
      .map((scenario) => {
        const groupName = this.sanitizeTestName(scenario.group);
        const tests = this.generateTests(scenario.tests, scenario.sheetId);

        return `test.describe("${groupName}", () => {
${tests}
});`;
      })
      .join("\n\n");
  }

  /**
   * ê°œë³„ í…ŒìŠ¤íŠ¸ë“¤ì„ ìƒì„±í•©ë‹ˆë‹¤.
   * @param tests í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ë°°ì—´
   * @param sheetId ì‹œíŠ¸ ID
   * @returns í…ŒìŠ¤íŠ¸ ì½”ë“œ
   */
  private generateTests(tests: TTestCase[], sheetId: string): string {
    return tests
      .map((test) => {
        const testName = this.sanitizeTestName(
          `[${test.path}] ${test.description}`
        );
        const testId = `${sheetId.toUpperCase()}_${test.testId}`;
        const metadata = this.generateTestMetadata(test, testId);
        const testBody = this.generateTestBody(test);

        return `  test.fixme("${testName}", async ({ page }) => {
${metadata}
${testBody}
  });`;
      })
      .join("\n\n");
  }

  /**
   * í…ŒìŠ¤íŠ¸ ë©”íƒ€ë°ì´í„° ì£¼ì„ì„ ìƒì„±í•©ë‹ˆë‹¤.
   * @param test í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤
   * @param testId í…ŒìŠ¤íŠ¸ ID
   * @returns ë©”íƒ€ë°ì´í„° ì£¼ì„
   */
  private generateTestMetadata(test: TTestCase, testId: string): string {
    return `    /**
     * ğŸ” Test Metadata
     * â”œâ”€â”€ ID: ${testId}
     * â”œâ”€â”€ Path: ${test.path}
     * â””â”€â”€ Description: ${test.description}
     */`;
  }

  /**
   * í…ŒìŠ¤íŠ¸ ë³¸ë¬¸ì„ ìƒì„±í•©ë‹ˆë‹¤.
   * @param test í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤
   * @returns í…ŒìŠ¤íŠ¸ ë³¸ë¬¸ ì½”ë“œ
   */
  private generateTestBody(test: TTestCase): string {
    const given = this.sanitizeComment(test.given);
    const when = this.sanitizeComment(test.when);
    const then = this.sanitizeComment(test.then);

    return `    
    // ğŸ¯ Given: ${given}
    
    // ğŸ¬ When: ${when}
    
    // âœ… Then: ${then}
    
    // ğŸš§ êµ¬í˜„ í›„ fixmeë¥¼ ì œê±°í•˜ì„¸ìš”.
    `;
  }

  /**
   * ì‹œë‚˜ë¦¬ì˜¤ë“¤ì„ screenIdë³„ë¡œ ê·¸ë£¹í™”í•©ë‹ˆë‹¤.
   * @param scenarios ì‹œë‚˜ë¦¬ì˜¤ ë°ì´í„° ë°°ì—´
   * @returns screenIdë³„ë¡œ ê·¸ë£¹í™”ëœ ì‹œë‚˜ë¦¬ì˜¤ ë°ì´í„°
   */
  private groupByScreenId(
    scenarios: TScenarioData[]
  ): Map<string, TScenarioData[]> {
    const grouped = new Map<string, TScenarioData[]>();

    scenarios.forEach((scenario) => {
      const screenId = scenario.screenId;
      if (!grouped.has(screenId)) {
        grouped.set(screenId, []);
      }
      grouped.get(screenId)!.push(scenario);
    });

    return grouped;
  }

  /**
   * í…ŒìŠ¤íŠ¸ ì´ë¦„ì—ì„œ íŠ¹ìˆ˜ ë¬¸ìë¥¼ ì œê±°í•˜ì—¬ ì•ˆì „í•œ ë¬¸ìì—´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
   * @param name ì›ë³¸ í…ŒìŠ¤íŠ¸ ì´ë¦„
   * @returns ì •ì œëœ í…ŒìŠ¤íŠ¸ ì´ë¦„
   */
  private sanitizeTestName(name: string): string {
    return name
      .replace(/"/g, '\\"') // ìŒë”°ì˜´í‘œ ì´ìŠ¤ì¼€ì´í”„
      .replace(/\n/g, " ") // ê°œí–‰ ë¬¸ì ì œê±°
      .replace(/\s+/g, " ") // ì—°ì†ëœ ê³µë°± ì •ë¦¬
      .trim();
  }

  /**
   * ì£¼ì„ì—ì„œ íŠ¹ìˆ˜ ë¬¸ìë¥¼ ì œê±°í•˜ì—¬ ì•ˆì „í•œ ë¬¸ìì—´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
   * @param comment ì›ë³¸ ì£¼ì„
   * @returns ì •ì œëœ ì£¼ì„
   */
  private sanitizeComment(comment: string): string {
    return comment
      .replace(/\n/g, " ") // ê°œí–‰ ë¬¸ì ì œê±°
      .replace(/\s+/g, " ") // ì—°ì†ëœ ê³µë°± ì •ë¦¬
      .trim();
  }

  /**
   * TProcessingError ê°ì²´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
   * @param type ì—ëŸ¬ íƒ€ì…
   * @param message ì—ëŸ¬ ë©”ì‹œì§€
   * @param filePath íŒŒì¼ ê²½ë¡œ (ì„ íƒì‚¬í•­)
   * @param originalError ì›ë³¸ ì—ëŸ¬ (ì„ íƒì‚¬í•­)
   * @returns TProcessingError ê°ì²´
   */
  private createProcessingError(
    type: TProcessingError["type"],
    message: string,
    filePath?: string,
    originalError?: Error
  ): TProcessingError {
    return {
      type,
      message,
      filePath,
      originalError,
    };
  }
}

export { TestCodeGenerator };
