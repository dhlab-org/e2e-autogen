import * as fs from "fs-extra";
import * as path from "path";
import {
  TScenarioData,
  TTestCase,
  TTestFileInfo,
  TProcessingError,
} from "./types";

class TestCodeGenerator implements TContract {
  async generateTestFiles(
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void> {
    try {
      // ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±
      await fs.ensureDir(outputDir);

      // screenIdë³„ë¡œ ê·¸ë£¹í™”
      const groupedByScreen = this.#groupByScreenId(scenarios);

      // ê° screenIdë³„ë¡œ í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„±
      const fileGenerationPromises = Array.from(groupedByScreen.entries()).map(
        ([screenId, screenScenarios]) =>
          this.#generateTestFile(screenId, screenScenarios, outputDir)
      );

      await Promise.all(fileGenerationPromises);
    } catch (error) {
      throw this.#createProcessingError(
        "FILE_WRITE",
        `í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„± ì‹¤íŒ¨: ${
          error instanceof Error ? error.message : String(error)
        }`,
        outputDir,
        error as Error
      );
    }
  }

  generateTestCode(scenarios: TScenarioData[]): string {
    const imports = this.#generateImports();
    const testGroups = this.#generateTestGroups(scenarios);

    return `// ğŸ“ Auto-generated by E2E-Autogen

${imports}

${testGroups}`;
  }

  async #generateTestFile(
    screenId: string,
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<TTestFileInfo> {
    try {
      // sheetIdë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸°ëŠ¥ ì˜ì—­ í´ë” ìƒì„±
      const sheetId = scenarios[0].sheetId;
      const featureDir = path.join(outputDir, sheetId);
      await fs.ensureDir(featureDir);

      const fileName = `${screenId}.spec.ts`;
      const filePath = path.join(featureDir, fileName);

      // í…ŒìŠ¤íŠ¸ ì½”ë“œ ìƒì„±
      const testCode = this.generateTestCode(scenarios);

      // íŒŒì¼ ì“°ê¸°
      await fs.writeFile(filePath, testCode, "utf-8");
      console.log(`âœ… ìƒì„±ë¨: ${filePath}`);

      return {
        fileName,
        filePath,
        screenId,
        sheetId,
      };
    } catch (error) {
      throw this.#createProcessingError(
        "FILE_WRITE",
        `í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„± ì‹¤íŒ¨ (${screenId}): ${
          error instanceof Error ? error.message : String(error)
        }`,
        outputDir,
        error as Error
      );
    }
  }

  #generateImports(): string {
    return `import { test } from "@playwright/test";`;
  }

  #generateTestGroups(scenarios: TScenarioData[]): string {
    return scenarios
      .map((scenario) => {
        const groupName = this.#sanitizeTestName(scenario.group);
        const tests = this.#generateTests(scenario.tests, scenario.sheetId);

        return `test.describe("${groupName}", () => {
${tests}
});`;
      })
      .join("\n\n");
  }

  #generateTests(tests: TTestCase[], sheetId: string): string {
    return tests
      .map((test) => {
        const testId = `${sheetId.toUpperCase()}_${test.testId}`;
        const testName = this.#sanitizeTestName(
          `[${testId}] ${test.description}`
        );
        const metadata = this.#generateTestMetadata(test, testId);
        const testBody = this.#generateTestBody(test);

        return `  test.fixme("${testName}", async ({ page }) => {
${metadata}
${testBody}
  });`;
      })
      .join("\n\n");
  }

  #generateTestMetadata(test: TTestCase, testId: string): string {
    return `    /**
     * ğŸ” Test Metadata
     * â”œâ”€â”€ ID: ${testId}
     * â”œâ”€â”€ Path: ${test.path}
     * â””â”€â”€ Description: ${test.description}
     */`;
  }

  #generateTestBody(test: TTestCase): string {
    const given = this.#sanitizeComment(test.given);
    const when = this.#sanitizeComment(test.when);
    const then = this.#sanitizeComment(test.then);

    return `    
    // ğŸ¯ Given: ${given}
    
    // ğŸ¬ When: ${when}
    
    // âœ… Then: ${then}
    
    // ğŸš§ êµ¬í˜„ í›„ fixmeë¥¼ ì œê±°í•˜ì„¸ìš”.
    `;
  }

  #groupByScreenId(scenarios: TScenarioData[]): Map<string, TScenarioData[]> {
    const grouped = new Map<string, TScenarioData[]>();

    scenarios.forEach((scenario) => {
      const screenId = scenario.screenId;
      if (!grouped.has(screenId)) {
        grouped.set(screenId, []);
      }
      grouped.get(screenId)!.push(scenario);
    });

    return grouped;
  }

  #sanitizeTestName(name: string): string {
    return name
      .replace(/"/g, '\\"') // ìŒë”°ì˜´í‘œ ì´ìŠ¤ì¼€ì´í”„
      .replace(/\n/g, " ") // ê°œí–‰ ë¬¸ì ì œê±°
      .replace(/\s+/g, " ") // ì—°ì†ëœ ê³µë°± ì •ë¦¬
      .trim();
  }

  #sanitizeComment(comment: string): string {
    return comment
      .replace(/\n/g, " ") // ê°œí–‰ ë¬¸ì ì œê±°
      .replace(/\s+/g, " ") // ì—°ì†ëœ ê³µë°± ì •ë¦¬
      .trim();
  }

  #createProcessingError(
    type: TProcessingError["type"],
    message: string,
    filePath?: string,
    originalError?: Error
  ): TProcessingError {
    return {
      type,
      message,
      filePath,
      originalError,
    };
  }
}

export { TestCodeGenerator };

type TContract = {
  generateTestFiles(
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void>;
  generateTestCode(scenarios: TScenarioData[]): string;
};
