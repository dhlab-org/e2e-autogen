import * as fs from "fs-extra";
import * as path from "path";
import {
  TScenarioData,
  TTestCase,
  TTestCodeGeneratorContract,
  TTestFileInfo,
  TProcessingError,
} from "./types";

class TestCodeGenerator implements TTestCodeGeneratorContract {
  /**
   * 시나리오 데이터로부터 Playwright 테스트 코드를 생성합니다.
   * @param scenarios 시나리오 데이터 배열
   * @param outputDir 출력 디렉토리 경로
   * @throws {TProcessingError} 파일 생성 실패 시
   */
  async generateTestFiles(
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void> {
    try {
      // 출력 디렉토리 생성
      await fs.ensureDir(outputDir);

      // screenId별로 그룹화
      const groupedByScreen = this.groupByScreenId(scenarios);

      // 각 screenId별로 테스트 파일 생성
      const fileGenerationPromises = Array.from(groupedByScreen.entries()).map(
        ([screenId, screenScenarios]) =>
          this.generateTestFile(screenId, screenScenarios, outputDir)
      );

      await Promise.all(fileGenerationPromises);
    } catch (error) {
      throw this.createProcessingError(
        "FILE_WRITE",
        `테스트 파일 생성 실패: ${
          error instanceof Error ? error.message : String(error)
        }`,
        outputDir,
        error as Error
      );
    }
  }

  /**
   * 단일 화면에 대한 테스트 파일을 생성합니다.
   * @param screenId 화면 ID
   * @param scenarios 해당 화면의 시나리오들
   * @param outputDir 출력 디렉토리
   * @returns 생성된 파일 정보
   */
  private async generateTestFile(
    screenId: string,
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<TTestFileInfo> {
    try {
      // sheetId를 사용하여 기능 영역 폴더 생성
      const sheetId = scenarios[0].sheetId;
      const featureDir = path.join(outputDir, sheetId);
      await fs.ensureDir(featureDir);

      const fileName = `${screenId}.spec.ts`;
      const filePath = path.join(featureDir, fileName);

      // 테스트 코드 생성
      const testCode = this.generateTestCode(scenarios);

      // 파일 쓰기
      await fs.writeFile(filePath, testCode, "utf-8");
      console.log(`✅ 생성됨: ${filePath}`);

      return {
        fileName,
        filePath,
        screenId,
        sheetId,
      };
    } catch (error) {
      throw this.createProcessingError(
        "FILE_WRITE",
        `테스트 파일 생성 실패 (${screenId}): ${
          error instanceof Error ? error.message : String(error)
        }`,
        outputDir,
        error as Error
      );
    }
  }

  /**
   * Playwright 테스트 코드를 생성합니다.
   * @param screenId 화면 ID
   * @param scenarios 시나리오 데이터 배열
   * @returns 생성된 테스트 코드
   */
  generateTestCode(scenarios: TScenarioData[]): string {
    const imports = this.generateImports();
    const testGroups = this.generateTestGroups(scenarios);

    return `// 📝 Auto-generated by E2E-Autogen

${imports}

${testGroups}`;
  }

  /**
   * import 문을 생성합니다.
   * @returns import 문
   */
  private generateImports(): string {
    return `import { test } from "@playwright/test";`;
  }

  /**
   * 테스트 그룹들을 생성합니다.
   * @param scenarios 시나리오 데이터 배열
   * @returns 테스트 그룹 코드
   */
  private generateTestGroups(scenarios: TScenarioData[]): string {
    return scenarios
      .map((scenario) => {
        const groupName = this.sanitizeTestName(scenario.group);
        const tests = this.generateTests(scenario.tests, scenario.sheetId);

        return `test.describe("${groupName}", () => {
${tests}
});`;
      })
      .join("\n\n");
  }

  /**
   * 개별 테스트들을 생성합니다.
   * @param tests 테스트 케이스 배열
   * @param sheetId 시트 ID
   * @returns 테스트 코드
   */
  private generateTests(tests: TTestCase[], sheetId: string): string {
    return tests
      .map((test) => {
        const testName = this.sanitizeTestName(
          `[${test.path}] ${test.description}`
        );
        const testId = `${sheetId.toUpperCase()}_${test.testId}`;
        const metadata = this.generateTestMetadata(test, testId);
        const testBody = this.generateTestBody(test);

        return `  test.fixme("${testName}", async ({ page }) => {
${metadata}
${testBody}
  });`;
      })
      .join("\n\n");
  }

  /**
   * 테스트 메타데이터 주석을 생성합니다.
   * @param test 테스트 케이스
   * @param testId 테스트 ID
   * @returns 메타데이터 주석
   */
  private generateTestMetadata(test: TTestCase, testId: string): string {
    return `    /**
     * 🔍 Test Metadata
     * ├── ID: ${testId}
     * ├── Path: ${test.path}
     * └── Description: ${test.description}
     */`;
  }

  /**
   * 테스트 본문을 생성합니다.
   * @param test 테스트 케이스
   * @returns 테스트 본문 코드
   */
  private generateTestBody(test: TTestCase): string {
    const given = this.sanitizeComment(test.given);
    const when = this.sanitizeComment(test.when);
    const then = this.sanitizeComment(test.then);

    return `    
    // 🎯 Given: ${given}
    
    // 🎬 When: ${when}
    
    // ✅ Then: ${then}
    
    // 🚧 구현 후 fixme를 제거하세요.
    `;
  }

  /**
   * 시나리오들을 screenId별로 그룹화합니다.
   * @param scenarios 시나리오 데이터 배열
   * @returns screenId별로 그룹화된 시나리오 데이터
   */
  private groupByScreenId(
    scenarios: TScenarioData[]
  ): Map<string, TScenarioData[]> {
    const grouped = new Map<string, TScenarioData[]>();

    scenarios.forEach((scenario) => {
      const screenId = scenario.screenId;
      if (!grouped.has(screenId)) {
        grouped.set(screenId, []);
      }
      grouped.get(screenId)!.push(scenario);
    });

    return grouped;
  }

  /**
   * 테스트 이름에서 특수 문자를 제거하여 안전한 문자열로 변환합니다.
   * @param name 원본 테스트 이름
   * @returns 정제된 테스트 이름
   */
  private sanitizeTestName(name: string): string {
    return name
      .replace(/"/g, '\\"') // 쌍따옴표 이스케이프
      .replace(/\n/g, " ") // 개행 문자 제거
      .replace(/\s+/g, " ") // 연속된 공백 정리
      .trim();
  }

  /**
   * 주석에서 특수 문자를 제거하여 안전한 문자열로 변환합니다.
   * @param comment 원본 주석
   * @returns 정제된 주석
   */
  private sanitizeComment(comment: string): string {
    return comment
      .replace(/\n/g, " ") // 개행 문자 제거
      .replace(/\s+/g, " ") // 연속된 공백 정리
      .trim();
  }

  /**
   * TProcessingError 객체를 생성합니다.
   * @param type 에러 타입
   * @param message 에러 메시지
   * @param filePath 파일 경로 (선택사항)
   * @param originalError 원본 에러 (선택사항)
   * @returns TProcessingError 객체
   */
  private createProcessingError(
    type: TProcessingError["type"],
    message: string,
    filePath?: string,
    originalError?: Error
  ): TProcessingError {
    return {
      type,
      message,
      filePath,
      originalError,
    };
  }
}

export { TestCodeGenerator };
