import * as fs from "fs-extra";
import * as path from "path";
import {
  TScenarioData,
  TTestCase,
  TTestFileInfo,
  TProcessingError,
} from "./types";

class TestCodeGenerator implements TContract {
  async generateTestFiles(
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void> {
    try {
      // 출력 디렉토리 생성
      await fs.ensureDir(outputDir);

      // screenId별로 그룹화
      const groupedByScreen = this.#groupByScreenId(scenarios);

      // 각 screenId별로 테스트 파일 생성
      const fileGenerationPromises = Array.from(groupedByScreen.entries()).map(
        ([screenId, screenScenarios]) =>
          this.#generateTestFile(screenId, screenScenarios, outputDir)
      );

      await Promise.all(fileGenerationPromises);
    } catch (error) {
      throw this.#createProcessingError(
        "FILE_WRITE",
        `테스트 파일 생성 실패: ${
          error instanceof Error ? error.message : String(error)
        }`,
        outputDir,
        error as Error
      );
    }
  }

  generateTestCode(scenarios: TScenarioData[]): string {
    const imports = this.#generateImports();
    const testGroups = this.#generateTestGroups(scenarios);

    return `// 📝 Auto-generated by E2E-Autogen

${imports}

${testGroups}`;
  }

  async #generateTestFile(
    screenId: string,
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<TTestFileInfo> {
    try {
      // sheetId를 사용하여 기능 영역 폴더 생성
      const sheetId = scenarios[0].sheetId;
      const featureDir = path.join(outputDir, sheetId);
      await fs.ensureDir(featureDir);

      const fileName = `${screenId}.spec.ts`;
      const filePath = path.join(featureDir, fileName);

      // 테스트 코드 생성
      const testCode = this.generateTestCode(scenarios);

      // 파일 쓰기
      await fs.writeFile(filePath, testCode, "utf-8");
      console.log(`✅ 생성됨: ${filePath}`);

      return {
        fileName,
        filePath,
        screenId,
        sheetId,
      };
    } catch (error) {
      throw this.#createProcessingError(
        "FILE_WRITE",
        `테스트 파일 생성 실패 (${screenId}): ${
          error instanceof Error ? error.message : String(error)
        }`,
        outputDir,
        error as Error
      );
    }
  }

  #generateImports(): string {
    return `import { test } from "@playwright/test";`;
  }

  #generateTestGroups(scenarios: TScenarioData[]): string {
    return scenarios
      .map((scenario) => {
        const groupName = this.#sanitizeTestName(scenario.group);
        const tests = this.#generateTests(scenario.tests, scenario.sheetId);

        return `test.describe("${groupName}", () => {
${tests}
});`;
      })
      .join("\n\n");
  }

  #generateTests(tests: TTestCase[], sheetId: string): string {
    return tests
      .map((test) => {
        const testId = `${sheetId.toUpperCase()}_${test.testId}`;
        const testName = this.#sanitizeTestName(
          `[${testId}] ${test.description}`
        );
        const metadata = this.#generateTestMetadata(test, testId);
        const testBody = this.#generateTestBody(test);

        return `  test.fixme("${testName}", async ({ page }) => {
${metadata}
${testBody}
  });`;
      })
      .join("\n\n");
  }

  #generateTestMetadata(test: TTestCase, testId: string): string {
    return `    /**
     * 🔍 Test Metadata
     * ├── ID: ${testId}
     * ├── Path: ${test.path}
     * └── Description: ${test.description}
     */`;
  }

  #generateTestBody(test: TTestCase): string {
    const given = this.#sanitizeComment(test.given);
    const when = this.#sanitizeComment(test.when);
    const then = this.#sanitizeComment(test.then);

    return `    
    // 🎯 Given: ${given}
    
    // 🎬 When: ${when}
    
    // ✅ Then: ${then}
    
    // 🚧 구현 후 fixme를 제거하세요.
    `;
  }

  #groupByScreenId(scenarios: TScenarioData[]): Map<string, TScenarioData[]> {
    const grouped = new Map<string, TScenarioData[]>();

    scenarios.forEach((scenario) => {
      const screenId = scenario.screenId;
      if (!grouped.has(screenId)) {
        grouped.set(screenId, []);
      }
      grouped.get(screenId)!.push(scenario);
    });

    return grouped;
  }

  #sanitizeTestName(name: string): string {
    return name
      .replace(/"/g, '\\"') // 쌍따옴표 이스케이프
      .replace(/\n/g, " ") // 개행 문자 제거
      .replace(/\s+/g, " ") // 연속된 공백 정리
      .trim();
  }

  #sanitizeComment(comment: string): string {
    return comment
      .replace(/\n/g, " ") // 개행 문자 제거
      .replace(/\s+/g, " ") // 연속된 공백 정리
      .trim();
  }

  #createProcessingError(
    type: TProcessingError["type"],
    message: string,
    filePath?: string,
    originalError?: Error
  ): TProcessingError {
    return {
      type,
      message,
      filePath,
      originalError,
    };
  }
}

export { TestCodeGenerator };

type TContract = {
  generateTestFiles(
    scenarios: TScenarioData[],
    outputDir: string
  ): Promise<void>;
  generateTestCode(scenarios: TScenarioData[]): string;
};
